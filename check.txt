ft_strtrim	: 1.OK 2.MOK 3.OK 4.MOK 5.OK 6.MOK ==380377== Argument 'size' of function malloc has a fishy (possibly negative) value: -11
==380377==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==380377==    by 0x404E35: ft_strtrim (in /home/fzhang/github/libft/Tester/a.out)
==380377==    by 0x404A53: main (ft_strtrim_test.cpp:31)
==380377== 
==380377== Invalid read of size 1
==380377==    at 0x484FBD4: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==380377==    by 0x404A6B: main (ft_strtrim_test.cpp:32)
==380377==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==380377== 
7.SIGSEGV

You are calling malloc() with a negative size (actually an unsigned size_t with a large value due to underflow).

You're passing a NULL pointer to strcmp. This likely means that ft_strtrim() returned NULL, and you're trying to compare that result with something.

Crash (SIGSEGV):

Segmentation fault (SIGSEGV) happened due to trying to read or write to invalid memory (probably a NULL or uninitialized pointer).


==385556== Invalid write of size 8
==385556==    at 0x405378: fillin_split
...
==385556==  Address 0x4de4330 is 0 bytes after a block of size 16 alloc'd

You're writing past the end of a memory block allocated by malloc.

The block was 16 bytes, and you're writing at offset 16 — that’s just outside the allocated memory.

This typically happens when:

You miscalculate the size needed for allocation.

Or you write one element too far in a loop (off-by-one error).

size n. how many bytes are written illegally

==393403== Conditional jump or move depends on uninitialised value(s)
means that your program is using a variable before it has been initialized — in this case, it's likely a string or char buffer returned from your ft_itoa function that is not properly null-terminated or contains uninitialized characters.

